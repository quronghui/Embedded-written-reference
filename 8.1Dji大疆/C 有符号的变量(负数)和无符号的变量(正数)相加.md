## 有符号变数与无符号数相加

1. 遵循的原则:  
   + 将有符号数转化为无符号数;
   + 取两个数的反码
2. [代码实例](https://github.com/quronghui/DataStructAndAlogrithmCode/blob/master/CompanyWrite/1_Dji/charConvertint.c)

### 理解原码, 反码, 补码

1. 机器数和真值概念:

   + 机器数:  

     + 一种**带符号**的**二进制**表示形式
     + 为了方便: 我们用一个byte来计算

     ```
     +3 :  0000 0011;
     -3	:  1000 0011;
     ```

   + 真值: 

     + **去掉符号位**后表示的值, 就是真值;

     + ```
       0000 0001 真值 = +000 0001 = +1;
       1000 0001 真值 = -000 0001 = -1;
       ```

2. 理解原码的概念

   + 原码: 是**符号位**加上**真值的绝对值**

     ```
     [+1]原 = 0000 0001
     [-1]原	=	1000 0001 
     ```

   + 带符号的8位二进制数的取值范围就是

     ```
     [1111 1111 , 0111 1111]  ==   [-127 , 127]
     ```

3. 理解反码的概念

   + 负数反码: 在原码的基础上**符号位不变**, 其余位取反(0/1);

   + 正数的反码: 是其本身;

     ```
     [+1] = [00000001]原 = [00000001]反
     [-1] = [10000001]原 = [11111110]反
     ```

4. 理解补码的概念

   + 负数的补码: 在反码的基础上, 最后位进行加1

   + 正数的补码: 是其本身

     ```
     [+1] = [00000001]原 = [00000001]反 = [00000001]补
     [-1] = [10000001]原 = [11111110]反 = [11111111]补
     ```

5. 关于负数

   + 其反码和补码都不能直接看出其数值;
   + 通常转化为原码才能看出;

### 为何要使用原码, 反码, 补码

1. 为了让机器的计算只有加法没有减法?

   1. 如果使用原码相加 : **结果不正确**

      ```
      1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
      ```

   2. 如果使用反码相加

      ```
      1 - 1 = 1 + (-1) =  [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
      ```

      + **"0"的特殊**: 存在+0 和 -0

      ```
      [0000 0000]原和[1000 0000]原  --> 都表示0
      ```

   3. 如果使用补码相加

      ```
      1-1 = 1 + (-1) =  [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
      ```

2. **问题一: 如果使用补码进行计算有什么问题呢?**

   ```
   (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
   ```

   + **0只有一种表示情况** [0000 0000];

   + **多表示一个最低数** : [1000 0000] = -128

   + 有符号的char型表示的数值

     ```
     [-128, 127] = [ -2^7  --  (2^7 -1)  ] 
     ```

### [减法变成加法的数学原理解析?](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

1. 数学问题的定义?

   + 钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?

   ```
   1. 往回拨2个小时: 6 - 2 = 4
   2. 往前拨10个小时: (6 + 10) mod 12 = 4
   3. 往前拨10+12=22个小时: (6+22) mod 12 =4
   ```

2. **问题二: 如何通过一个正数, 代替一个负数?**

   1. 同余的概念:  两个整数a，b，若它们除以整数m所得的**余数相等**

      ```
      记做:   a = b( mod m)
      ```

   2. 负数如何取模?

      + **取下界  b / m**  :  L(-1.5) = (-2);  L( 1.5 ) = 1   

      ```
      b mod m  = b  -  m * L( b / m ) 
      ```

      + 例子

        ```
        -3 mod 2 = -3  -  2 * L(-3/2)  = -3  - 2 * L(-1.5)  =  -3 - 2*(-2) = 1
        ```

   3. 如何通过一个正数, 代替一个负数?

      + **找到这个负数的同余数**

      ```
      7 ≡ 7 (mod 12)
      (-2) ≡ 10 (mod 12)  ;   -2 mod 12 = 10 ;  10 mod 12 = 10
      所以此时就能替换: 7 + ( -2 ) ≡ 7 + 10 (mod 12)
      ```

3. 将同余的概念应用到二进制:

   + **负数的二进制同余: 就是其补码;**