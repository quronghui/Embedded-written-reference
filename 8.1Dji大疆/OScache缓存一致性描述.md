## [Cache 缓存一致性的问题](https://www.infoq.cn/article/cache-coherency-primer)

+ 多组缓存, 通过共享总线的机制, 使用MESI协议, 实现缓存一致性;
+ 写操作: 只有缓存段处于某一个处理器独占E的时, 才允许写;

### 缓存

1. 缓存的作用?

   + 加快虚拟地址与物理地址的转换;
   + 能见的地址空间: 程序运行时OS为其分配的虚拟存储位置; 

2. 缓存的存储空间?

   + 缓存是分“段”（line）的，一个段对应一块存储空间
   + 大小: 32 byte / 64 byte / 128 byte
   + 每个CPU缓存 : 有多个缓存;

3. 所有级别的缓存遵循基本定律:

   ```
   在任意时刻，**任意级别**缓存中的缓存段的内容，等同于它对应的内存中的内容。
   ```

4. **问题一: ** 允许写操作有几种方式?

   + **直写**: 透过本级缓存，直接把数据写到下一级缓存（或直接到内存）中，如果对应的段被缓存了，我们同时更新缓存中的内容（甚至直接丢弃）
   + **回写: **
     + 仅修改本级缓存中的数据，并且把对应的缓存段标记为“脏”段
     + 脏段会触发回写: 把里面的内容写到对应的内存或下一级缓存中;

5. 回写的优势的定律?

   + 回写模式：它能过滤掉对同一地址的反复写操作

   ```
   回写定律：当所有的脏段被回写后，**任意级别**缓存中的缓存段的内容，等同于它对应的内存中的内容。
   ```

### 一致性问题  

+ 针对: 内存中的内容

1. 一致性问题的产生?
   + 如果某个 **CPU 缓存段中对应的内存内容**被另外一个 CPU 偷偷修改.
   + 使多组缓存的**内容**保持一致。
2. **问题一:** 如何解决缓存之间的一致性问题?
   + 总体方法: 如果一个 CPU 缓存了某块内存，那么在其他 CPU 修改这块内存的时候，希望得到通知
   + 具体方法: 通过一个**共享总线**连接多个缓存; 

### **直写共享总线使用的协议** : “窥探（snooping）协议”

+ 具体思想:  *所有内存传输* 都发生在一条共享的总线上，而*所有的处理器*都能看到这条总线;
  + 缓存本身是独立的，但是内存是共享资源
+ 内存访问的仲裁:
  + 同一个指令周期中，只有一个缓存可以读写内存;
+ 缓存失效
  + 某个处理器一写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的段已经失效。

+ 直写模式下, 写操作一旦发生, 效果就会马上"公布";

### 回写模式: 共享总线使用的协议 MESI

1. MESI 协议:
   + MESI 是**四种缓存段**状态的首字母缩写
   + 失效（Invalid）缓存段
     + 要么已经不在缓存中，要么它的内容已经过时(被更新)
     + 一旦缓存段被**标记为失效**，那效果就等同于它从来没被加载到缓存中。
   + 共享(Shared)缓存段
     + 和主内存内容保持一致的**一份拷贝**，在这种状态下的缓存段**只能被读取，不能被写入**
     + **多组缓存**可以同时拥有针对同一内存地址的共享缓存段
   + 独占(Exclusive)缓存段
     + 和主内存内容保持一致的**一份拷贝**;
     + **独占**: 同一时间只能有一个处理器持有E 状态的缓存段
   + 已修改(Modified)缓存段
     + 属于脏段: 缓存内存被修改;
     + 已修改状态: 那么它在其他处理器缓存中的拷贝马上会变成**失效状态**
2. **MESI 协议如何实现一致性呢?**
   + 处理器是**独占**这个缓存段:	
     + 只有当缓存段处于 E 或 M 状态时，处理器才能去**写**它;
   + 写操作: 申请独占权:
     + 在总线上发送"我要独占权"的请求;
     + 这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效
   + 读操作: 缓存段必须先回到“共享”状态
     + 通过回写
3. MESI定律
   + 在所有的脏缓存段（M 状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。
   + 在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E 状态），那它就不会再出现在其他任何处理器的缓存中。